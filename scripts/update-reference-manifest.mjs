#!/usr/bin/env node
import { promises as fs } from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const rootDir = path.resolve(__dirname, "..");
const referencesDir = path.join(rootDir, "packages", "website", "references");
const manifestPath = path.join(rootDir, "packages", "cli", "src", "reference-manifest.ts");
const manifestDir = path.dirname(manifestPath);
const skillPath = path.join(rootDir, "SKILL.md");

async function collectMarkdownFiles(dir, prefix = "") {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files = [];

  for (const entry of entries) {
    const relativePath = prefix ? `${prefix}/${entry.name}` : entry.name;
    const absolutePath = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      files.push(...(await collectMarkdownFiles(absolutePath, relativePath)));
    } else if (/\.(md|mdx)$/i.test(entry.name)) {
      files.push(relativePath);
    }
  }

  return files;
}

const toIdentifier = (fileName) => {
  const base = fileName
    .replace(/[^a-zA-Z0-9]/g, "_")
    .replace(/^_+/, "")
    .replace(/^([0-9])/, "_$1");
  return `REF_${base || "FILE"}`;
};

async function main() {
  try {
    await fs.access(referencesDir);
  } catch {
    throw new Error(`References directory not found at ${referencesDir}`);
  }

  try {
    await fs.access(skillPath);
  } catch {
    throw new Error(`SKILL.md not found at ${skillPath}`);
  }

  const files = (await collectMarkdownFiles(referencesDir)).sort((a, b) =>
    a.localeCompare(b),
  );

  const relativeSkillPath = path
    .relative(manifestDir, skillPath)
    .split(path.sep)
    .join("/");
  const importSkill = `import SKILL_DOCUMENT_RAW from "${relativeSkillPath}" with { type: "text" };`;
  const importReferences = files
    .map((file) => {
      const identifier = toIdentifier(file);
      const absoluteReferencePath = path.join(referencesDir, file);
      const relativeReferencePath = path
        .relative(manifestDir, absoluteReferencePath)
        .split(path.sep)
        .join("/");
      const sourcePath = relativeReferencePath;
      return `import ${identifier} from "${sourcePath}" with { type: "text" };`;
    })
    .join("\n");

  const referenceContentObject = files
    .map((file) => {
      const identifier = toIdentifier(file);
      return `  ${JSON.stringify(file)}: ${identifier},`;
    })
    .join("\n");

  const banner = "// Auto-generated by scripts/update-reference-manifest.mjs";
  const content = `${banner}
${importSkill}
${importReferences}

export const SKILL_DOCUMENT = SKILL_DOCUMENT_RAW;

export const REFERENCE_FILES = ${JSON.stringify(files, null, 2)} as const;

export type ReferenceFile = (typeof REFERENCE_FILES)[number];

export const REFERENCE_CONTENT: Record<ReferenceFile, string> = {
${referenceContentObject}
};
`;
  await fs.writeFile(manifestPath, content, "utf8");

  console.log(`Updated reference manifest with ${files.length} entries.`);
}

main().catch((error) => {
  console.error(error);
  process.exit(1);
});
